{
  "language": "Solidity",
  "sources": {
    "src/Blockies.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport \"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\";\nimport \"solidity-kit/solc_0.8/ERC721/ERC4494/implementations/UsingERC4494PermitWithDynamicChainId.sol\";\nimport \"solidity-kit/solc_0.8/ERC173/interfaces/IERC173.sol\";\nimport \"solidity-kit/solc_0.8/ERC721/TokenURI/interfaces/IContractURI.sol\";\nimport \"./ERC721OwnedByAll.sol\";\n\n/// @notice Blockies as NFT. Each ethereum address owns its own Blocky NFT. No minting needed.\n/// You can even use Permit (EIP-4494) to approve contracts via signatures.\n/// Note though that unless you transfer or call `emitSelfTransferEvent` indexer would not know of your token.\n/// @title On-chain Blockies\ncontract Blockies is ERC721OwnedByAll, UsingERC4494PermitWithDynamicChainId, IERC721Metadata, IContractURI {\n\terror AlreadyClaimed();\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// TEMPLATE\n\t// ------------------------------------------------------------------------------------------------------------------\n\tbytes internal constant TOKEN_URI_TEMPLATE =\n\t\t'data:application/json,{\"name\":\"0x0000000000000000000000000000000000000000\",\"description\":\"Blocky%200x0000000000000000000000000000000000000000%20Generated%20On-Chain\",\"image\":\"';\n\n\t// 31 start position for address in name\n\t// 41 = length of address - 1\n\tuint256 internal constant ADDRESS_NAME_POS = 31 + 41; // 72\n\n\t// 18 = distance\n\t// 9 = Blocky%20\n\t// 41 = length of address - 1\n\tuint256 internal constant ADDRESS_NAME_2_POS = ADDRESS_NAME_POS + 18 + 9 + 41; // 140\n\n\tbytes internal constant SVG_TEMPLATE =\n\t\t\"data:image/svg+xml,<svg%20xmlns='http://www.w3.org/2000/svg'%20shape-rendering='crispEdges'%20width='512'%20height='512'><g%20transform='scale(64)'><path%20fill='hsl(000,000%,000%)'%20d='M0,0h8v8h-8z'/><path%20fill='hsl(000,000%,000%)'%20d='M0,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1z'/><path%20fill='hsl(000,000%,000%)'%20d='M0,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm-8,1m1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1zm1,0h1v0h-1z'/></g></svg>\";\n\n\tuint256 internal constant COLOR_BG_POS = 168;\n\n\t// 54 = distance\n\tuint256 internal constant COLOR_1_POS = COLOR_BG_POS + 54; // 222\n\t// 18 = distance\n\tuint256 internal constant PATH_1_POS = COLOR_1_POS + 18; // 240\n\n\t// 827 = distance\n\tuint256 internal constant COLOR_2_POS = PATH_1_POS + 827; // 1067\n\t// 18 = distance\n\tuint256 internal constant PATH_2_POS = COLOR_2_POS + 18; // 1085\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// DATA AND TYPES\n\t// ------------------------------------------------------------------------------------------------------------------\n\tbytes internal constant hexAlphabet = \"0123456789abcdef\";\n\n\tstruct Seed {\n\t\tint32 s0;\n\t\tint32 s1;\n\t\tint32 s2;\n\t\tint32 s3;\n\t}\n\n\t/// @notice owner of the contract, can claim this contract's blocky\n\t/// no other role granted\n\taddress public immutable owner;\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// CONSTRUCTOR\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tconstructor(address contractOwner) UsingERC712WithDynamicChainId(address(0)) ERC721OwnedByAll(contractOwner) {\n\t\towner = contractOwner;\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// EXTERNAL INTERFACE\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\t/// @inheritdoc IERC721Metadata\n\tfunction name() public pure override(IERC721Metadata, Named) returns (string memory) {\n\t\treturn \"Blockies\";\n\t}\n\n\t/// @inheritdoc IERC721Metadata\n\tfunction symbol() external pure returns (string memory) {\n\t\treturn \"BLOCKY\";\n\t}\n\n\t/// @inheritdoc IERC721Metadata\n\tfunction tokenURI(uint256 id) external pure override returns (string memory str) {\n\t\tbytes memory metadata = TOKEN_URI_TEMPLATE;\n\t\t_writeUintAsHex(metadata, ADDRESS_NAME_POS, id);\n\t\t_writeUintAsHex(metadata, ADDRESS_NAME_2_POS, id);\n\n\t\treturn string(bytes.concat(metadata, _renderSVG(id), '\"}'));\n\t}\n\n\t/// @inheritdoc IContractURI\n\tfunction contractURI() external view returns (string memory) {\n\t\treturn\n\t\t\tstring(\n\t\t\t\tbytes.concat(\n\t\t\t\t\t'data:application/json,{\"name\":\"On-chain%20Blockies\",\"description\":\"The%20original%20Blockies,%20but%20fully%20generated%20on-chain.%20Each%20Ethereum%20address%20owns%20its%20own%20unique%20Blocky%20NFT.\",\"image\":\"',\n\t\t\t\t\t_renderSVG(uint160(address(this))),\n\t\t\t\t\t'\"}'\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/// @inheritdoc IERC165\n\tfunction supportsInterface(bytes4 id)\n\t\tpublic\n\t\tview\n\t\toverride(BasicERC721, UsingERC4494Permit, IERC165)\n\t\treturns (bool)\n\t{\n\t\treturn BasicERC721.supportsInterface(id) || UsingERC4494Permit.supportsInterface(id);\n\t}\n\n\t/// @notice emit Transfer event so that indexer can pick it up.\n\t///   This can be called by anyone at any time and does not change state\n\t///   As such it keeps the token's operator-approval state and will re-emit an Approval event to indicate that.\n\t/// @param id tokenID to emit the event for.\n\tfunction emitSelfTransferEvent(uint256 id) external {\n\t\t(address currentowner, , bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(id);\n\t\tif (currentowner == address(0)) {\n\t\t\trevert NonExistentToken(id);\n\t\t}\n\n\t\temit Transfer(currentowner, currentowner, id);\n\n\t\tif (operatorEnabled) {\n\t\t\t// we reemit the Approval as Transfer event indicate a reset, as per ERC721 spec\n\t\t\temit Approval(currentowner, _operators[id], id);\n\t\t}\n\t}\n\n\t/// @notice claim ownership of the blocky if you are the owner of a contract\n\t/// @param id blocky address to claim\n\tfunction claimOwnership(uint256 id) external {\n\t\t(address currentowner, uint256 nonce) = _ownerAndNonceOf(id);\n\t\tif (currentowner == address(0)) {\n\t\t\trevert NonExistentToken(id);\n\t\t}\n\n\t\tbool registered = (nonce >> 24) != 0;\n\t\tif (registered) {\n\t\t\trevert AlreadyClaimed();\n\t\t}\n\n\t\tif (currentowner.code.length == 0 || IERC173(currentowner).owner() != msg.sender) {\n\t\t\trevert NotAuthorized();\n\t\t}\n\n\t\t_transferFrom(currentowner, msg.sender, id, false);\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tfunction _writeUint(\n\t\tbytes memory data,\n\t\tuint256 endPos,\n\t\tuint256 num\n\t) internal pure {\n\t\twhile (num != 0) {\n\t\t\tdata[endPos--] = bytes1(uint8(48 + (num % 10)));\n\t\t\tnum /= 10;\n\t\t}\n\t}\n\n\tfunction _seedrand(bytes memory seed) internal pure returns (Seed memory randseed) {\n\t\tunchecked {\n\t\t\tfor (uint256 i = 0; i < seed.length; i++) {\n\t\t\t\tuint8 j = uint8(i % 4);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trandseed.s0 = (randseed.s0 << 5) - randseed.s0 + int32(uint32(uint8(seed[i])));\n\t\t\t\t} else if (j == 1) {\n\t\t\t\t\trandseed.s1 = (randseed.s1 << 5) - randseed.s1 + int32(uint32(uint8(seed[i])));\n\t\t\t\t} else if (j == 2) {\n\t\t\t\t\trandseed.s2 = (randseed.s2 << 5) - randseed.s2 + int32(uint32(uint8(seed[i])));\n\t\t\t\t} else if (j == 3) {\n\t\t\t\t\trandseed.s3 = (randseed.s3 << 5) - randseed.s3 + int32(uint32(uint8(seed[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _rand(Seed memory randseed) internal pure returns (uint256 rnd) {\n\t\tunchecked {\n\t\t\tint32 t = randseed.s0 ^ int32(randseed.s0 << 11);\n\t\t\trandseed.s0 = randseed.s1;\n\t\t\trandseed.s1 = randseed.s2;\n\t\t\trandseed.s2 = randseed.s3;\n\t\t\trandseed.s3 = randseed.s3 ^ (randseed.s3 >> 19) ^ t ^ (t >> 8);\n\t\t\trnd = uint32(randseed.s3);\n\t\t}\n\t}\n\n\tfunction _randhsl(Seed memory randseed)\n\t\tinternal\n\t\tpure\n\t\treturns (\n\t\t\tuint16 hue,\n\t\t\tuint8 saturation,\n\t\t\tuint8 lightness\n\t\t)\n\t{\n\t\tunchecked {\n\t\t\t// saturation is the whole color spectrum\n\t\t\thue = uint16(((_rand(randseed) * 360) / 2147483648));\n\t\t\t// saturation goes from 40 to 100, it avoids greyish colors\n\t\t\tsaturation = uint8((_rand(randseed) * 60) / 2147483648 + 40);\n\t\t\t// lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%\n\t\t\tlightness = uint8(\n\t\t\t\t((_rand(randseed) + _rand(randseed) + _rand(randseed) + _rand(randseed)) * 25) / 2147483648\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction _setColor(\n\t\tbytes memory metadata,\n\t\tSeed memory randseed,\n\t\tuint8 i\n\t) internal pure {\n\t\t(uint16 hue, uint8 saturation, uint8 lightness) = _randhsl(randseed);\n\t\tuint256 pos = COLOR_BG_POS;\n\t\tif (i == 1) {\n\t\t\tpos = COLOR_1_POS;\n\t\t} else if (i == 2) {\n\t\t\tpos = COLOR_2_POS;\n\t\t}\n\t\t_writeUint(metadata, pos + 0, hue);\n\t\t_writeUint(metadata, pos + 4, saturation);\n\t\t_writeUint(metadata, pos + 9, lightness);\n\t}\n\n\tfunction _writeUintAsHex(\n\t\tbytes memory data,\n\t\tuint256 endPos,\n\t\tuint256 num\n\t) internal pure {\n\t\twhile (num != 0) {\n\t\t\tdata[endPos--] = bytes1(hexAlphabet[num % 16]);\n\t\t\tnum /= 16;\n\t\t}\n\t}\n\n\tfunction _addressToString(address who) internal pure returns (string memory) {\n\t\tbytes memory addr = \"0x0000000000000000000000000000000000000000\";\n\t\t_writeUintAsHex(addr, 41, uint160(who));\n\t\treturn string(addr);\n\t}\n\n\tfunction _setPixel(\n\t\tbytes memory metadata,\n\t\tuint256 x,\n\t\tuint256 y,\n\t\tuint8 color\n\t) internal pure {\n\t\tuint256 pathPos = 0;\n\t\tif (color == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (color == 1) {\n\t\t\tpathPos = PATH_1_POS;\n\t\t} else if (color == 2) {\n\t\t\tpathPos = PATH_2_POS;\n\t\t}\n\t\tuint256 pos = pathPos + y * 5 + (y * 8 + x) * 12 + 8;\n\t\tmetadata[pos] = \"1\";\n\t}\n\n\tfunction _renderSVG(uint256 id) internal pure returns (bytes memory) {\n\t\tbytes memory svg = SVG_TEMPLATE;\n\n\t\tSeed memory randseed = _seedrand(bytes(_addressToString(address(uint160(id)))));\n\n\t\t_setColor(svg, randseed, 1);\n\t\t_setColor(svg, randseed, 0);\n\t\t_setColor(svg, randseed, 2);\n\n\t\tfor (uint256 y = 0; y < 8; y++) {\n\t\t\tuint8 p0 = uint8((_rand(randseed) * 23) / 2147483648 / 10);\n\t\t\tuint8 p1 = uint8((_rand(randseed) * 23) / 2147483648 / 10);\n\t\t\tuint8 p2 = uint8((_rand(randseed) * 23) / 2147483648 / 10);\n\t\t\tuint8 p3 = uint8((_rand(randseed) * 23) / 2147483648 / 10);\n\n\t\t\t_setPixel(svg, 0, y, p0);\n\t\t\t_setPixel(svg, 1, y, p1);\n\t\t\t_setPixel(svg, 2, y, p2);\n\t\t\t_setPixel(svg, 3, y, p3);\n\t\t\t_setPixel(svg, 4, y, p3);\n\t\t\t_setPixel(svg, 5, y, p2);\n\t\t\t_setPixel(svg, 6, y, p1);\n\t\t\t_setPixel(svg, 7, y, p0);\n\t\t}\n\n\t\treturn svg;\n\t}\n}\n"
    },
    "src/ERC721OwnedByAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol\";\n\nabstract contract ERC721OwnedByAll is BasicERC721, IERC721Supply {\n\tconstructor(address initialOwnerOfTokenIdZero) {\n\t\tif (initialOwnerOfTokenIdZero == address(0)) {\n\t\t\t//ensure address zero do not own any token\n\t\t\tinitialOwnerOfTokenIdZero = address(this);\n\t\t}\n\t\t_transferFrom(address(0), initialOwnerOfTokenIdZero, 0, false);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction balanceOf(address owner) public view override returns (uint256 balance) {\n\t\tbalance = super.balanceOf(owner);\n\n\t\t(, uint256 nonce) = _ownerAndNonceOf(uint256(uint160(owner)));\n\t\tif (nonce >> 24 == 0) {\n\t\t\t// self token was never registered\n\t\t\tunchecked {\n\t\t\t\tbalance++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721WithBlocknumber\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata ids)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (OwnerData[] memory ownersData)\n\t{\n\t\townersData = new OwnerData[](ids.length);\n\t\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\t\tuint256 id = ids[i];\n\t\t\tuint256 data = _owners[id];\n\t\t\taddress owner = address(uint160(data));\n\t\t\tif (owner == address(0) && id < 2**160) {\n\t\t\t\towner = address(uint160(id));\n\t\t\t}\n\t\t\townersData[i].owner = owner;\n\t\t\townersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721Supply\n\tfunction totalSupply() external pure returns (uint256) {\n\t\treturn 2**160;\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tfunction _ownerOf(uint256 id) internal view override returns (address owner) {\n\t\towner = super._ownerOf(id);\n\t\tif (owner == address(0) && id < 2**160) {\n\t\t\towner = address(uint160(id));\n\t\t}\n\t}\n\n\tfunction _ownerAndOperatorEnabledOf(uint256 id)\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (address owner, bool operatorEnabled)\n\t{\n\t\t(owner, operatorEnabled) = super._ownerAndOperatorEnabledOf(id);\n\t\tif (owner == address(0) && id < 2**160) {\n\t\t\towner = address(uint160(id));\n\t\t}\n\t}\n\n\tfunction _ownerAndNonceOf(uint256 id) internal view override returns (address owner, uint256 nonce) {\n\t\t(owner, nonce) = super._ownerAndNonceOf(id);\n\t\tif (owner == address(0) && id < 2**160) {\n\t\t\towner = address(uint160(id));\n\t\t}\n\t}\n\n\tfunction _ownerNonceAndOperatorEnabledOf(uint256 id)\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\taddress owner,\n\t\t\tuint256 nonce,\n\t\t\tbool operatorEnabled\n\t\t)\n\t{\n\t\t(owner, nonce, operatorEnabled) = super._ownerNonceAndOperatorEnabledOf(id);\n\t\tif (owner == address(0) && id < 2**160) {\n\t\t\towner = address(uint160(id));\n\t\t}\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Metadata is IERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC173/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../utils/GenericErrors.sol\";\n\ninterface IERC173 {\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/// @notice Get the address of the owner\n\t/// @return The address of the owner.\n\tfunction owner() external view returns (address);\n\n\t/// @notice Set the address of the new owner of the contract\n\t/// @dev Set newOwner to address(0) to renounce any ownership.\n\t/// @param newOwner The address of the new owner of the contract\n\tfunction transferOwnership(address newOwner) external;\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/ERC4494/implementations/UsingERC4494PermitWithDynamicChainId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./UsingERC4494Permit.sol\";\nimport \"../../../ERC712/implementations/UsingERC712WithDynamicChainId.sol\";\n\nabstract contract UsingERC4494PermitWithDynamicChainId is UsingERC4494Permit, UsingERC712WithDynamicChainId {\n\t/// @inheritdoc ImplementingExternalDomainSeparator\n\tfunction DOMAIN_SEPARATOR() public view virtual override returns (bytes32) {\n\t\treturn _currentDomainSeparator();\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/TokenURI/interfaces/IContractURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IExternalContractURI {\n\t/// @notice Returns the Uniform Resource Identifier (URI) for the token collection.\n\tfunction contractURI(address receiver, uint96 per10Thousands) external view returns (string memory);\n}\n\ninterface IContractURI {\n\t/// @notice Returns the Uniform Resource Identifier (URI) for the token collection.\n\tfunction contractURI() external view returns (string memory);\n}\n\ninterface IERC721WithExternalContractURI is IContractURI {\n\tevent ContractURIAddressSet(IExternalContractURI newContractURIAddress);\n\tevent ContractURIAdminSet(address newContractURIAdmin);\n\n\terror NotAuthorized();\n\n\t/// @notice the contract that return the contract metadata\n\tfunction contractURIAddress() external returns (IExternalContractURI);\n\n\t/// @notice contractURIAdmin can update the ContractURI contract, this is intended to be relinquished.\n\tfunction contractURIAdmin() external returns (address);\n\n\t/// @notice set the new contractURIAdmin that can change the contractURI\n\t/// Can only be called by the current contractURI admin.\n\tfunction setContractURIAdmin(address newContractURIAdmin) external;\n\n\t/// @notice set a new contractURI contract, that generate the metadata including the wav file, Can only be set by the `contractURIAdmin`.\n\t/// @param newContractURIAddress The address of the new contractURI contract.\n\tfunction setContractURI(IExternalContractURI newContractURIAddress) external;\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721WithBlocknumber.sol\";\nimport \"./ImplementingERC721Internal.sol\";\n\nimport \"../../openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract BasicERC721 is IERC721, IERC721WithBlocknumber, ImplementingERC721Internal {\n\tusing Openzeppelin_Address for address;\n\n\tbytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\n\tuint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\tmapping(uint256 => uint256) internal _owners;\n\tmapping(address => uint256) internal _balances;\n\tmapping(address => mapping(address => bool)) internal _operatorsForAll;\n\tmapping(uint256 => address) internal _operators;\n\n\t/// @inheritdoc IERC721\n\tfunction approve(address operator, uint256 tokenId) external override {\n\t\t(address owner, uint256 nonce) = _ownerAndNonceOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenId);\n\t\t}\n\t\tif (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n\t\t\trevert NotAuthorized();\n\t\t}\n\t\t_approveFor(owner, nonce, operator, tokenId);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external override {\n\t\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenId);\n\t\t}\n\t\tif (from != owner) {\n\t\t\trevert NotOwner(from, owner);\n\t\t}\n\t\tif (to == address(0) || to == address(this)) {\n\t\t\trevert InvalidAddress(to);\n\t\t}\n\t\tif (msg.sender != from) {\n\t\t\tif (!(operatorEnabled && _operators[tokenId] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n\t\t\t\trevert NotAuthorized();\n\t\t\t}\n\t\t}\n\t\t_transferFrom(from, to, tokenId, (nonce >> 24) != 0);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external override {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction setApprovalForAll(address operator, bool approved) external override {\n\t\t_setApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction balanceOf(address owner) public view virtual override returns (uint256 balance) {\n\t\tif (owner == address(0)) {\n\t\t\trevert InvalidAddress(owner);\n\t\t}\n\t\tbalance = _balances[owner];\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction ownerOf(uint256 tokenId) external view override returns (address owner) {\n\t\towner = _ownerOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenId);\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction getApproved(uint256 tokenId) external view override returns (address operator) {\n\t\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenId);\n\t\t}\n\t\tif (operatorEnabled) {\n\t\t\treturn _operators[tokenId];\n\t\t} else {\n\t\t\treturn address(0);\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\n\t\treturn _operatorsForAll[owner][operator];\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public override {\n\t\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenId);\n\t\t}\n\t\tif (owner != from) {\n\t\t\trevert NotOwner(from, owner);\n\t\t}\n\n\t\tif (to == address(0) || to == address(this)) {\n\t\t\trevert InvalidAddress(to);\n\t\t}\n\n\t\tif (msg.sender != from) {\n\t\t\tif (!(operatorEnabled && _operators[tokenId] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n\t\t\t\trevert NotAuthorized();\n\t\t\t}\n\t\t}\n\t\t_safeTransferFrom(from, to, tokenId, (nonce >> 24) != 0, data);\n\t}\n\n\t/// @inheritdoc IERC165\n\tfunction supportsInterface(bytes4 id) public view virtual override returns (bool) {\n\t\t/// 0x01ffc9a7 is ERC165.\n\t\t/// 0x80ac58cd is ERC721\n\t\t/// 0x5b5e139f is for ERC721 metadata\n\t\treturn id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n\t}\n\n\t/// @inheritdoc IERC721WithBlocknumber\n\tfunction ownerAndLastTransferBlockNumberOf(uint256 id)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (address owner, uint256 blockNumber)\n\t{\n\t\t(address currentOwner, uint256 nonce) = _ownerAndNonceOf(id);\n\t\towner = currentOwner;\n\t\tblockNumber = (nonce >> 24);\n\t}\n\n\t/// @inheritdoc IERC721WithBlocknumber\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata ids)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\treturns (OwnerData[] memory ownersData)\n\t{\n\t\townersData = new OwnerData[](ids.length);\n\t\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\t\tuint256 data = _owners[ids[i]];\n\t\t\townersData[i].owner = address(uint160(data));\n\t\t\townersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\n\t\t}\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tfunction _safeMint(address to, uint256 id) internal {\n\t\t_safeTransferFrom(address(0), to, id, false, \"\");\n\t}\n\n\tfunction _safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbool registered,\n\t\tbytes memory data\n\t) internal {\n\t\t_transferFrom(from, to, id, registered);\n\t\tif (to.isContract()) {\n\t\t\tif (!_checkOnERC721Received(msg.sender, from, to, id, data)) {\n\t\t\t\trevert TransferRejected();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbool registered\n\t) internal virtual {\n\t\tunchecked {\n\t\t\t_balances[to]++;\n\t\t\tif (registered) {\n\t\t\t\t_balances[from]--;\n\t\t\t}\n\t\t}\n\n\t\t// We encode the blockNumber in the token nonce. We can then use it for count voting.\n\t\t_owners[id] = (block.number << 184) | uint256(uint160(to));\n\t\temit Transfer(from, to, id);\n\t}\n\n\t/// @dev See approve.\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 nonce,\n\t\taddress operator,\n\t\tuint256 id\n\t) internal override {\n\t\tuint256 blockNumber = nonce >> 24;\n\t\tuint256 newNonce = nonce + 1;\n\t\tif (newNonce >> 24 != blockNumber) {\n\t\t\trevert NonceOverflow();\n\t\t}\n\t\tif (operator == address(0)) {\n\t\t\t_owners[id] = (newNonce << 160) | uint256(uint160(owner));\n\t\t} else {\n\t\t\t_owners[id] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\n\t\t\t_operators[id] = operator;\n\t\t}\n\t\temit Approval(owner, operator, id);\n\t}\n\n\t/// @dev See setApprovalForAll.\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal override {\n\t\t_operatorsForAll[sender][operator] = approved;\n\n\t\temit ApprovalForAll(sender, operator, approved);\n\t}\n\n\t/// @dev Check if receiving contract accepts erc721 transfers.\n\t/// @param operator The address of the operator.\n\t/// @param from The from address, may be different from msg.sender.\n\t/// @param to The adddress we want to transfer to.\n\t/// @param id The id of the token we would like to transfer.\n\t/// @param data Any additional data to send with the transfer.\n\t/// @return Whether the expected value of 0x150b7a02 is returned.\n\tfunction _checkOnERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbytes memory data\n\t) internal returns (bool) {\n\t\tbytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, id, data);\n\t\treturn (retval == ERC721_RECEIVED);\n\t}\n\n\t/// @dev See ownerOf\n\tfunction _ownerOf(uint256 id) internal view virtual returns (address owner) {\n\t\treturn address(uint160(_owners[id]));\n\t}\n\n\t/// @dev Get the owner and operatorEnabled status of a token.\n\t/// @param id The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return operatorEnabled Whether or not operators are enabled for this token.\n\tfunction _ownerAndOperatorEnabledOf(uint256 id)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (address owner, bool operatorEnabled)\n\t{\n\t\tuint256 data = _owners[id];\n\t\towner = address(uint160(data));\n\t\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n\t}\n\n\t/// @dev Get the owner and the permit nonce of a token.\n\t/// @param id The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n\tfunction _ownerAndNonceOf(uint256 id) internal view virtual override returns (address owner, uint256 nonce) {\n\t\tuint256 data = _owners[id];\n\t\towner = address(uint160(data));\n\t\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n\n\t// @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\n\t/// @param id The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n\t/// @return operatorEnabled Whether or not operators are enabled for this token.\n\tfunction _ownerNonceAndOperatorEnabledOf(uint256 id)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (\n\t\t\taddress owner,\n\t\t\tuint256 nonce,\n\t\t\tbool operatorEnabled\n\t\t)\n\t{\n\t\tuint256 data = _owners[id];\n\t\towner = address(uint160(data));\n\t\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n\t\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param operator The address which called `safeTransferFrom` function\n\t/// @param from The address which previously owned the token\n\t/// @param tokenId The NFT identifier which is being transferred\n\t/// @param data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external returns (bytes4);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721WithBlocknumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721WithBlocknumber {\n\t/// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\n\t/// @param id The id of the token.\n\t/// @return owner The address of the token owner.\n\t/// @return blockNumber The blocknumber at which the last transfer of that id happened.\n\tfunction ownerAndLastTransferBlockNumberOf(uint256 id) external view returns (address owner, uint256 blockNumber);\n\n\tstruct OwnerData {\n\t\taddress owner;\n\t\tuint256 lastTransferBlockNumber;\n\t}\n\n\t/// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\n\t/// @param ids The list of token ids to check.\n\t/// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata ids)\n\t\texternal\n\t\tview\n\t\treturns (OwnerData[] memory ownersData);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../ERC165/interfaces/IERC165.sol\";\n\ninterface IERC721Supply {\n\tfunction totalSupply() external view returns (uint256);\n}\n\ninterface IERC721 is IERC165 {\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\terror NonExistentToken(uint256 tokenID);\n\terror NotAuthorized();\n\terror NotOwner(address provided, address expected);\n\terror InvalidAddress(address invalid);\n\terror TransferRejected();\n\terror NonceOverflow();\n\n\t/// @notice Get the number of tokens owned by an address.\n\t/// @param owner The address to look for.\n\t/// @return balance The number of tokens owned by the address.\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/// @notice Get the owner of a token.\n\t/// @param tokenId The id of the token.\n\t/// @return owner The address of the token owner.\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenId The id of the token.\n\t/// @param data Additional data.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external;\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n\t/// @param from The send of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenId The id of the token.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/// @notice Transfer a token between 2 addresses.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenId The id of the token.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/// @notice Approve an operator to transfer a specific token on the senders behalf.\n\t/// @param operator The address receiving the approval.\n\t/// @param tokenId The id of the token.\n\tfunction approve(address operator, uint256 tokenId) external;\n\n\t/// @notice Set the approval for an operator to manage all the tokens of the sender.\n\t/// @param operator The address receiving the approval.\n\t/// @param approved The determination of the approval.\n\tfunction setApprovalForAll(address operator, bool approved) external;\n\n\t/// @notice Get the approved operator for a specific token.\n\t/// @param tokenId The id of the token.\n\t/// @return operator The address of the operator.\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\n\n\t/// @notice Check if the sender approved the operator.\n\t/// @param owner The address of the owner.\n\t/// @param operator The address of the operator.\n\t/// @return isOperator The status of the approval.\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/implementations/ImplementingERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ImplementingERC721Internal {\n\tfunction _ownerAndNonceOf(uint256 id) internal view virtual returns (address owner, uint256 nonce);\n\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 nonce,\n\t\taddress operator,\n\t\tuint256 id\n\t) internal virtual;\n\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal virtual;\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Openzeppelin_Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * You shouldn't rely on `isContract` to protect against flash loan attacks!\n\t *\n\t * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n\t * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n\t * constructor.\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// This method relies on extcodesize/address.code.length, which returns 0\n\t\t// for contracts in construction, since the code is only stored at the end\n\t\t// of the constructor execution.\n\n\t\treturn account.code.length > 0;\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t */\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\t/**\n\t * @dev Performs a Solidity function call using a low level `call`. A\n\t * plain `call` is an unsafe replacement for a function call: use this\n\t * function instead.\n\t *\n\t * If `target` reverts with a revert reason, it is bubbled up by this\n\t * function (like regular Solidity function calls).\n\t *\n\t * Returns the raw returned data. To convert to the expected return value,\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\t *\n\t * Requirements:\n\t *\n\t * - `target` must be a contract.\n\t * - calling `target` with `data` must not revert.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but also transferring `value` wei to `target`.\n\t *\n\t * Requirements:\n\t *\n\t * - the calling contract must have an ETH balance of at least `value`.\n\t * - the called Solidity function must be `payable`.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal view returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n\t * revert reason using the provided one.\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction verifyCallResult(\n\t\tbool success,\n\t\tbytes memory returndata,\n\t\tstring memory errorMessage\n\t) internal pure returns (bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\t\t\t\t/// @solidity memory-safe-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n\t/// @notice Query if a contract implements an interface\n\t/// @param interfaceID The interface identifier, as specified in ERC-165\n\t/// @dev Interface identification is specified in ERC-165. This function\n\t///  uses less than 30,000 gas.\n\t/// @return `true` if the contract implements `interfaceID` and\n\t///  `interfaceID` is not 0xffffffff, `false` otherwise\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0.8/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nerror NotAuthorized();\n"
    },
    "solidity-kit/solc_0.8/ERC712/implementations/UsingERC712WithDynamicChainId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./UsingERC712.sol\";\nimport \"./Named.sol\";\n\nabstract contract UsingERC712WithDynamicChainId is UsingERC712, Named {\n\tuint256 private immutable _deploymentChainId;\n\tbytes32 private immutable _deploymentDomainSeparator;\n\n\tconstructor(address verifyingContract) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\t_deploymentChainId = chainId;\n\t\t_deploymentDomainSeparator = _calculateDomainSeparator(\n\t\t\tchainId,\n\t\t\tverifyingContract == address(0) ? address(this) : verifyingContract\n\t\t);\n\t}\n\n\t/// @inheritdoc IERC5267\n\tfunction eip712Domain()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (\n\t\t\tbytes1 fields,\n\t\t\tstring memory name,\n\t\t\tstring memory version,\n\t\t\tuint256 chainId,\n\t\t\taddress verifyingContract,\n\t\t\tbytes32 salt,\n\t\t\tuint256[] memory extensions\n\t\t)\n\t{\n\t\tfields = 0x0D;\n\t\tname = _name();\n\t\tversion = \"\";\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\tverifyingContract = address(this);\n\t\tsalt = 0;\n\t\textensions = new uint256[](0);\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\t// need to ensure we can use return value \"name\" in `eip712Domain`\n\tfunction _name() internal view returns (string memory) {\n\t\treturn name();\n\t}\n\n\tfunction _currentDomainSeparator() internal view returns (bytes32) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\t// in case a fork happen, to support the chain that had to change its chainId, we compute the domain operator\n\t\treturn\n\t\t\tchainId == _deploymentChainId\n\t\t\t\t? _deploymentDomainSeparator\n\t\t\t\t: _calculateDomainSeparator(chainId, address(this));\n\t}\n\n\t/// @dev Calculate the Domain Separator used to compute ERC712 hash\n\tfunction _calculateDomainSeparator(uint256 chainId, address verifyingContract) private view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tkeccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"),\n\t\t\t\t\tkeccak256(bytes(name())),\n\t\t\t\t\tchainId,\n\t\t\t\t\tverifyingContract\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/ERC4494/implementations/UsingERC4494Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../implementations/ImplementingERC721Internal.sol\";\nimport \"../../../ERC165/implementations/UsingERC165Internal.sol\";\nimport \"../interfaces/IERC4494.sol\";\nimport \"../../../ERC712/implementations/UsingERC712.sol\";\nimport \"../../../ERC712/implementations/ImplementingExternalDomainSeparator.sol\";\nimport \"../../../ERC721/interfaces/IERC721.sol\";\n\nimport \"../../..//openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"../../../openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract UsingERC4494Permit is\n\tIERC4494,\n\tIERC4494PermitForAll,\n\tIERC4494Alternative,\n\tImplementingERC721Internal,\n\tUsingERC165Internal,\n\tImplementingExternalDomainSeparator,\n\tUsingERC712\n{\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH =\n\t\tkeccak256(\"PermitForAll(address owner,address spender,uint256 nonce,uint256 deadline)\");\n\n\tmapping(address => uint256) internal _userNonces;\n\n\t/// @inheritdoc IERC4494PermitForAll\n\tfunction nonces(address account) external view virtual returns (uint256 nonce) {\n\t\treturn _userNonces[account];\n\t}\n\n\t/// @inheritdoc IERC4494\n\tfunction nonces(uint256 id) public view virtual returns (uint256 nonce) {\n\t\t(address owner, uint256 currentNonce) = _ownerAndNonceOf(id);\n\t\tif (owner == address(0)) {\n\t\t\trevert IERC721.NonExistentToken(id);\n\t\t}\n\t\treturn currentNonce;\n\t}\n\n\t/// @inheritdoc IERC4494Alternative\n\tfunction tokenNonces(uint256 tokenId) external view returns (uint256 nonce) {\n\t\treturn nonces(tokenId);\n\t}\n\n\t/// @inheritdoc IERC4494\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory sig\n\t) external override(IERC4494, IERC4494Alternative) {\n\t\tif (block.timestamp > deadline) {\n\t\t\trevert DeadlineOver(block.timestamp, deadline);\n\t\t}\n\n\t\t(address owner, uint256 nonce) = _ownerAndNonceOf(tokenId);\n\t\tif (owner == address(0)) {\n\t\t\trevert IERC721.NonExistentToken(tokenId);\n\t\t}\n\n\t\t_requireValidPermit(owner, spender, tokenId, deadline, nonce, sig);\n\n\t\t_approveFor(owner, nonce, spender, tokenId);\n\t}\n\n\t/// @inheritdoc IERC4494PermitForAll\n\tfunction permitForAll(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 deadline,\n\t\tbytes memory sig\n\t) external {\n\t\tif (block.timestamp > deadline) {\n\t\t\trevert DeadlineOver(block.timestamp, deadline);\n\t\t}\n\n\t\t_requireValidPermitForAll(owner, spender, deadline, _userNonces[owner]++, sig);\n\n\t\t_setApprovalForAll(owner, spender, true);\n\t}\n\n\t/// @inheritdoc IERC165\n\tfunction supportsInterface(bytes4 id) public view virtual override(IERC165, UsingERC165Internal) returns (bool) {\n\t\treturn\n\t\t\tsuper.supportsInterface(id) ||\n\t\t\tid == type(IERC4494).interfaceId ||\n\t\t\tid == type(IERC4494Alternative).interfaceId;\n\t}\n\n\t/// @inheritdoc ImplementingExternalDomainSeparator\n\tfunction DOMAIN_SEPARATOR()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride(IERC4494, IERC4494PermitForAll, IERC4494Alternative, ImplementingExternalDomainSeparator)\n\t\treturns (bytes32);\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tfunction _requireValidPermit(\n\t\taddress signer,\n\t\taddress spender,\n\t\tuint256 id,\n\t\tuint256 deadline,\n\t\tuint256 nonce,\n\t\tbytes memory sig\n\t) internal view {\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, spender, id, nonce, deadline))\n\t\t\t)\n\t\t);\n\t\tif (!Openzeppelin_SignatureChecker.isValidSignatureNow(signer, digest, sig)) {\n\t\t\trevert InvalidSignature();\n\t\t}\n\t}\n\n\tfunction _requireValidPermitForAll(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 deadline,\n\t\tuint256 nonce,\n\t\tbytes memory sig\n\t) internal view {\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\tkeccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, owner, spender, nonce, deadline))\n\t\t\t)\n\t\t);\n\t\tif (!Openzeppelin_SignatureChecker.isValidSignatureNow(owner, digest, sig)) {\n\t\t\trevert InvalidSignature();\n\t\t}\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC712/implementations/Named.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Named {\n\t/// @notice Returns the name of the contract.\n\tfunction name() public view virtual returns (string memory);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC712/implementations/UsingERC712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC5267.sol\";\n\nabstract contract UsingERC712 is IERC5267 {}\n"
    },
    "solidity-kit/solc_0.8/ERC712/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n\t/// @notice The return values of this function MUST describe the domain separator that is used for verification of EIP-712 signatures in the contract. They describe both the form of the EIP712Domain struct (i.e., which of the optional fields and extensions are present) and the value of each field, as follows.\n\t/// @return fields A bit map where bit i is set to 1 if and only if domain field i is present (0  i  4). Bits are read from least significant to most significant, and fields are indexed in the order that is specified by EIP-712, identical to the order in which they are listed in the function type.\n\t/// @return name EIP-712 name\n\t/// @return version EIP-712 version\n\t/// @return chainId EIP-712 chainId\n\t/// @return verifyingContract EIP-712 name verifyingContract\n\t/// @return salt EIP-712 salt\n\t/// @return extensions A list of EIP numbers that specify additional fields in the domain. The method to obtain the value for each of these additional fields and any conditions for inclusion are expected to be specified in the respective EIP. The value of fields does not affect their inclusion.\n\tfunction eip712Domain()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tbytes1 fields,\n\t\t\tstring memory name,\n\t\t\tstring memory version,\n\t\t\tuint256 chainId,\n\t\t\taddress verifyingContract,\n\t\t\tbytes32 salt,\n\t\t\tuint256[] memory extensions\n\t\t);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC165/implementations/UsingERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165.sol\";\n\nabstract contract UsingERC165Internal is IERC165 {\n\t/// @inheritdoc IERC165\n\tfunction supportsInterface(bytes4) public view virtual returns (bool) {\n\t\treturn false;\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC712/implementations/ImplementingExternalDomainSeparator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ImplementingExternalDomainSeparator {\n\t/// @notice EIP-712 Domain separator hash\n\tfunction DOMAIN_SEPARATOR() public view virtual returns (bytes32);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/ERC4494/interfaces/IERC4494.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../../ERC165/interfaces/IERC165.sol\";\n\ninterface IERC4494 is IERC165 {\n\terror DeadlineOver(uint256 currentTime, uint256 deadline);\n\terror InvalidSignature();\n\n\t/// @notice EIP-712 Domain separator hash\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/// @notice Allows to retrieve current nonce for token\n\t/// @param tokenId token id\n\t/// @return nonce token nonce\n\tfunction nonces(uint256 tokenId) external view returns (uint256 nonce);\n\n\t/// @notice function to be called by anyone to approve `spender` using a Permit signature\n\t/// @dev Anyone can call this to approve `spender`, even a third-party\n\t/// @param spender the actor to approve\n\t/// @param tokenId the token id\n\t/// @param deadline the deadline for the permit to be used\n\t/// @param signature permit\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external;\n}\n\ninterface IERC4494PermitForAll {\n\t/// @notice EIP-712 Domain separator hash\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/// @notice Allows to retrieve current nonce for the account\n\t/// @param account account to query\n\t/// @return nonce account's nonce\n\tfunction nonces(address account) external view returns (uint256 nonce);\n\n\t/// @notice function to be called by anyone to approve `spender` using a Permit signature\n\t/// @dev Anyone can call this to approve `spender`, even a third-party\n\t/// @param signer the one giving permission\n\t/// @param spender the actor to approve\n\t/// @param deadline the deadline for the permit to be used\n\t/// @param signature permit\n\tfunction permitForAll(\n\t\taddress signer,\n\t\taddress spender,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external;\n}\n\ninterface IERC4494Alternative is IERC165 {\n\t/// @notice EIP-712 Domain separator hash\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/// @notice Allows to retrieve current nonce for token\n\t/// @param tokenId token id\n\t/// @return nonce token nonce\n\tfunction tokenNonces(uint256 tokenId) external view returns (uint256 nonce);\n\n\t/// @notice function to be called by anyone to approve `spender` using a Permit signature\n\t/// @dev Anyone can call this to approve `spender`, even a third-party\n\t/// @param spender the actor to approve\n\t/// @param tokenId the token id\n\t/// @param deadline the deadline for the permit to be used\n\t/// @param signature permit\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external;\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.1) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary Openzeppelin_SignatureChecker {\n\t/**\n\t * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n\t * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n\t *\n\t * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n\t * change through time. It could return true at block N and false at block N+1 (or the opposite).\n\t */\n\tfunction isValidSignatureNow(\n\t\taddress signer,\n\t\tbytes32 hash,\n\t\tbytes memory signature\n\t) internal view returns (bool) {\n\t\t(address recovered, Openzeppelin_ECDSA.RecoverError error) = Openzeppelin_ECDSA.tryRecover(hash, signature);\n\t\tif (error == Openzeppelin_ECDSA.RecoverError.NoError && recovered == signer) {\n\t\t\treturn true;\n\t\t}\n\n\t\t(bool success, bytes memory result) = signer.staticcall(\n\t\t\tabi.encodeWithSelector(Openzeppelin_IERC1271.isValidSignature.selector, hash, signature)\n\t\t);\n\t\treturn (success &&\n\t\t\tresult.length == 32 &&\n\t\t\tabi.decode(result, (bytes32)) == bytes32(Openzeppelin_IERC1271.isValidSignature.selector));\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface Openzeppelin_IERC1271 {\n\t/**\n\t * @dev Should return whether the signature provided is valid for the provided data\n\t * @param hash      Hash of the data to be signed\n\t * @param signature Signature byte array associated with _data\n\t */\n\tfunction isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary Openzeppelin_ECDSA {\n\tenum RecoverError {\n\t\tNoError,\n\t\tInvalidSignature,\n\t\tInvalidSignatureLength,\n\t\tInvalidSignatureS,\n\t\tInvalidSignatureV\n\t}\n\n\tfunction _throwError(RecoverError error) private pure {\n\t\tif (error == RecoverError.NoError) {\n\t\t\treturn; // no error: do nothing\n\t\t} else if (error == RecoverError.InvalidSignature) {\n\t\t\trevert(\"ECDSA: invalid signature\");\n\t\t} else if (error == RecoverError.InvalidSignatureLength) {\n\t\t\trevert(\"ECDSA: invalid signature length\");\n\t\t} else if (error == RecoverError.InvalidSignatureS) {\n\t\t\trevert(\"ECDSA: invalid signature 's' value\");\n\t\t} else if (error == RecoverError.InvalidSignatureV) {\n\t\t\trevert(\"ECDSA: invalid signature 'v' value\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature` or error string. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t *\n\t * Documentation for signature generation:\n\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n\t\tif (signature.length == 65) {\n\t\t\tbytes32 r;\n\t\t\tbytes32 s;\n\t\t\tuint8 v;\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\t/// @solidity memory-safe-assembly\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := mload(add(signature, 0x40))\n\t\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t\t}\n\t\t\treturn tryRecover(hash, v, r, s);\n\t\t} else {\n\t\t\treturn (address(0), RecoverError.InvalidSignatureLength);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature`. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t */\n\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\t\t(address recovered, RecoverError error) = tryRecover(hash, signature);\n\t\t_throwError(error);\n\t\treturn recovered;\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n\t *\n\t * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction tryRecover(\n\t\tbytes32 hash,\n\t\tbytes32 r,\n\t\tbytes32 vs\n\t) internal pure returns (address, RecoverError) {\n\t\tbytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n\t\tuint8 v = uint8((uint256(vs) >> 255) + 27);\n\t\treturn tryRecover(hash, v, r, s);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n\t *\n\t * _Available since v4.2._\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tbytes32 r,\n\t\tbytes32 vs\n\t) internal pure returns (address) {\n\t\t(address recovered, RecoverError error) = tryRecover(hash, r, vs);\n\t\t_throwError(error);\n\t\treturn recovered;\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction tryRecover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address, RecoverError) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\tif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\t\t\treturn (address(0), RecoverError.InvalidSignatureS);\n\t\t}\n\t\tif (v != 27 && v != 28) {\n\t\t\treturn (address(0), RecoverError.InvalidSignatureV);\n\t\t}\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\tif (signer == address(0)) {\n\t\t\treturn (address(0), RecoverError.InvalidSignature);\n\t\t}\n\n\t\treturn (signer, RecoverError.NoError);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t(address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n\t\t_throwError(error);\n\t\treturn recovered;\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n\t\t// 32 is the length in bytes of hash,\n\t\t// enforced by the type signature above\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from `s`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Openzeppelin_Strings.toString(s.length), s));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Typed Data, created from a\n\t * `domainSeparator` and a `structHash`. This produces hash corresponding\n\t * to the one signed with the\n\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n\t * JSON-RPC method as part of EIP-712.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Openzeppelin_Strings {\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\tuint8 private constant _ADDRESS_LENGTH = 20;\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n\t */\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\t// Inspired by OraclizeAPI's implementation - MIT licence\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tbytes memory buffer = new bytes(digits);\n\t\twhile (value != 0) {\n\t\t\tdigits -= 1;\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\t\t\tvalue /= 10;\n\t\t}\n\t\treturn string(buffer);\n\t}\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n\t */\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0x00\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 length = 0;\n\t\twhile (temp != 0) {\n\t\t\tlength++;\n\t\t\ttemp >>= 8;\n\t\t}\n\t\treturn toHexString(value, length);\n\t}\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n\t */\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n\t\tbytes memory buffer = new bytes(2 * length + 2);\n\t\tbuffer[0] = \"0\";\n\t\tbuffer[1] = \"x\";\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\n\t\t\tbuffer[i] = _HEX_SYMBOLS[value & 0xf];\n\t\t\tvalue >>= 4;\n\t\t}\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\n\t\treturn string(buffer);\n\t}\n\n\t/**\n\t * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n\t */\n\tfunction toHexString(address addr) internal pure returns (string memory) {\n\t\treturn toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}